<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql优化</title>
      <link href="/2022/07/19/mysql-you-hua/"/>
      <url>/2022/07/19/mysql-you-hua/</url>
      
        <content type="html"><![CDATA[<p>一，优化思路</p><p>作为架构师或者开发人员，说到数据库性能优化，你的思路是什么样的？ 或者具体一点，如果在面试的时候遇到这个问题：你会从哪些维度来优化数据库，你会怎么回答？ 我们在第一章开始的时候讲了，这章的目标是为了让大家建立数据库的知识体系，和正确的调优的思路。 我们说到性能调优，大部分时候想要实现的目标是让我们的查询更快。一个查询的动作又是由很多个环节组成的，每个环节都会消耗时间，我们在第一章讲 SQL 语句的执行流程的时候已经分析过了。 我们要减少查询所消耗的时间，就要从每一个环节入手。</p><p><img src="https://pics7.baidu.com/feed/86d6277f9e2f07089822af4d65659490a901f227.png?token=dea7519df35e358208570537d77e53f8" alt="img"></p><p>sql执行流程.png</p><p>在项目里面，方会开启事务，或者配置了事务？无论是在方法上加注解，还是配置切面。</p><h3 id="一，连接——配置优化"><a href="#一，连接——配置优化" class="headerlink" title="一，连接——配置优化"></a>一，连接——配置优化</h3><p>第一个环节是客户端连接到服务端，连接这一块有可能会出现什么样的性能问题？有可能是服务端连接数不够导致应用程序获取不到连接。比如报了一个 Mysql: error 1040: Too many connections 的错误。 我们可以从两个方面来解决连接数不够的问题： 1、从服务端来说，我们可以增加服务端的可用连接数。 如果有多个应用或者很多请求同时访问数据库，连接数不够的时候，我们可以： （1）修改配置参数增加可用连接数，修改 max_connections 的大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;max_connections&#x27;; -- 修改最大连接数，当有多个应用连接的时候</span><br></pre></td></tr></table></figure><p>（2）或者，或者及时释放不活动的连接。交互式和非交互式的客户端的默认超时时间都是 28800 秒，8 小时，我们可以把这个值调小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#x27;wait_timeout&#x27;; --及时释放不活动的连接，注意不要释放连接池还在使用的连接</span><br></pre></td></tr></table></figure><p>2、从客户端来说，可以减少从服务端获取的连接数，如果我们想要不是每一次执行SQL 都创建一个新的连接，应该怎么做？ 这个时候我们可以引入连接池，实现连接的重用。 我们可以在哪些层面使用连接池？ORM 层面（MyBatis 自带了一个连接池）；或者使用专用的连接池工具（阿里的 Druid、Spring Boot 2.x 版本默认的连接池 Hikari、老牌的 DBCP 和 C3P0）。 当客户端改成从连接池获取连接之后，连接池的大小应该怎么设置呢？大家可能会有一个误解，觉得连接池的最大连接数越大越好，这样在高并发的情况下客户端可以获取的连接数更多，不需要排队。 实际情况并不是这样。连接池并不是越大越好，只要维护一定数量大小的连接池，其他的客户端排队等待获取连接就可以了。有的时候连接池越大，效率反而越低。 Druid 的默认最大连接池大小是 8。Hikari 的默认最大连接池大小是 10。为什么默认值都是这么小呢？ 在 Hikari 的 github 文档中，给出了一个 PostgreSQL 数据库建议的设置连接池大小的公式： github.com&#x2F;brettwooldridge&#x2F;HikariCP&#x2F;wiki&#x2F;About-Pool-Sizing 它的建议是机器核数乘以 2 加 1。也就是说，4 核的机器，连接池维护 9 个连接就够了。这个公式从一定程度上来说对其他数据库也是适用的。这里面还有一个减少连接池大小实现提升并发度和吞吐量的案例。 为什么有的情况下，减少连接数反而会提升吞吐量呢？为什么建议设置的连接池大小要跟 CPU 的核数相关呢？ 每一个连接，服务端都需要创建一个线程去处理它。连接数越多，服务端创建的线程数就会越多。 问题：CPU 是怎么同时执行远远超过它的核数大小的任务的？时间片。上下文切换。 而 CPU 的核数是有限的，频繁的上下文切换会造成比较大的性能开销。 我们这里说到了从数据库配置的层面去优化数据库。不管是数据库本身的配置，还是安装这个数据库服务的操作系统的配置，对于配置进行优化，最终的目标都是为了更好地发挥硬件本身的性能，包括 CPU、内存、磁盘、网络。 在不同的硬件环境下，操作系统和 MySQL 的参数的配置是不同的，没有标准的配置。 在我们前面也接触了很多的 MySQL 和 InnoDB 的配置参数，包括各种开关和数值的配置，大多数参数都提供了一个默认值，比如默认的 buffer_pool_size，默认的页大小，InnoDB 并发线程数等等。 这些默认配置可以满足大部分情况的需求，除非有特殊的需求，在清楚参数的含义的情况下再去修改它。修改配置的工作一般由专业的 DBA 完成。 至于硬件本身的选择，比如使用固态硬盘，搭建磁盘阵列，选择特定的 CPU 型号这些，更不是我们开发人员关注的重点，这个我们就不做过多的介绍了。 如果想要了解一些特定的参数的含义，官网有一份系统的参数列表可以参考： dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;server-system-variables.html 除了合理设置服务端的连接数和客户端的连接池大小之外，我们还有哪些减少客户端跟数据库服务端的连接数的方案呢？ 我们可以引入缓存。</p><h3 id="三，缓存——架构优化"><a href="#三，缓存——架构优化" class="headerlink" title="三，缓存——架构优化"></a>三，缓存——架构优化</h3><ol><li><p>缓存</p><p>在应用系统的并发数非常大的情况下，如果没有缓存，会造成两个问题：一方面是会给数据库带来很大的压力。另一方面，从应用的层面来说，操作数据的速度也会受到影响。</p><p>我们可以用第三方的缓存服务来解决这个问题，例如 Redis。</p></li></ol><p><img src="https://pics7.baidu.com/feed/91529822720e0cf32496e6358e07de16bf09aa62.png?token=3d9d7cc5450444d6a6ac417d4555dd3b" alt="img"></p><p>缓存.png</p><p>运行独立的缓存服务，属于架构层面的优化。 为了减少单台数据库服务器的读写压力，在架构层面我们还可以做其他哪些优化措施？</p><ol><li><p>主从复制</p><p>如果单台数据库服务满足不了访问需求，那我们可以做数据库的集群方案。 集群的话必然会面临一个问题，就是不同的节点之间数据一致性的问题。如果同时读写多台数据库节点，怎么让所有的节点数据保持一致？ 这个时候我们需要用到复制技术（replication），被复制的节点称为 master，复制的节点称为 slave。slave 本身也可以作为其他节点的数据来源，这个叫做级联复制。</p></li></ol><p><img src="https://pics1.baidu.com/feed/32fa828ba61ea8d3b43cf8d0134b1c47241f5896.png?token=433148c50c98b5e164926a83585f6b77" alt="img"></p><p>主从复制.png</p><p>主从复制是怎么实现的呢？更新语句会记录 binlog，它是一种逻辑日志。</p><p>有了这个 binlog，从服务器会获取主服务器的 binlog 文件，然后解析里面的 SQL语句，在从服务器上面执行一遍，保持主从的数据一致。</p><p>这里面涉及到三个线程，连接到 master 获取 binlog，并且解析 binlog 写入中继日志，这个线程叫做 I&#x2F;O 线程。</p><p>Master 节点上有一个 log dump 线程，是用来发送 binlog 给 slave 的。</p><p>从库的 SQL 线程，是用来读取 relay log，把数据写入到数据库的。</p><p><img src="https://pics4.baidu.com/feed/8601a18b87d6277f8aa857d7ae793339e824fc75.png?token=2080bce907c708300073fe611ae2a1cd" alt="img"></p><p>master-slave.png</p><p>做了主从复制的方案之后，我们只把数据写入 master 节点，而读的请求可以分担到slave 节点。我们把这种方案叫做读写分离。</p><p><img src="https://pics7.baidu.com/feed/b151f8198618367a7668fb54aa32a7ddb21ce525.png?token=8f685d1881bf8d2596bee9d0fd2177ad" alt="img"></p><p>读写分离.png</p><p>读写分离可以一定程度低减轻数据库服务器的访问压力，但是需要特别注意主从数据一致性的问题。如果我们在 master 写入了，马上到 slave 查询，而这个时候 slave 的数据还没有同步过来，怎么办？</p><p>所以，基于主从复制的原理，我们需要弄明白，主从复制到底慢在哪里？</p><ul><li><p>单线程</p><p>在早期的 MySQL 中，slave 的 SQL 线程是单线程。master 可以支持 SQL 语句的并行执行，配置了多少的最大连接数就是最多同时多少个 SQL 并行执行。</p><p>而 slave 的 SQL 却只能单线程排队执行，在主库并发量很大的情况下，同步数据肯定会出现延迟。</p><p>为什么从库上的 SQL Thread 不能并行执行呢？举个例子，主库执行了多条 SQL 语句，首先用户发表了一条评论，然后修改了内容，最后把这条评论删除了。这三条语句在从库上的执行顺序肯定是不能颠倒的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into user_comments (10000009,&#x27;nice&#x27;);</span><br><span class="line">updateset content =&#x27;very good&#x27; where id =10000009;</span><br><span class="line">delete fromwhere id =10000009;</span><br></pre></td></tr></table></figure><p>怎么解决这个问题呢？怎么减少主从复制的延迟？</p></li><li><p>异步与全同步</p><p>首先我们需要知道，在主从复制的过程中，MySQL 默认是异步复制的。也就是说，对于主节点来说，写入 binlog，事务结束，就返回给客户端了。对于 slave 来说，接收到 binlog，就完事儿了，master 不关心 slave 的数据有没有写入成功。</p></li></ul><p><img src="https://pics4.baidu.com/feed/a686c9177f3e670929e7582bb286b334fadc55cd.png?token=0517e229a76aa1772541f2532d1176f7" alt="img"></p><p>全同步复制.png</p><p>如果要减少延迟，是不是可以等待全部从库的事务执行完毕，才返回给客户端呢？这样的方式叫做全同步复制。从库写完数据，主库才返会给客户端。</p><p>这种方式虽然可以保证在读之前，数据已经同步成功了，但是带来的副作用大家应该能想到，事务执行的时间会变长，它会导致 master 节点性能下降</p><p>有没有更好的办法呢？既减少 slave 写入的延迟，又不会明显增加 master 返回给客户端的时间？</p><ul><li><p>半同步复制</p><p>介于异步复制和全同步复制之间，还有一种半同步复制的方式。</p><p>半同步复制是什么样的呢？</p><p>主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到 binlog 并写到 relay log 中才返回给客户端。master 不会等待很长的时间，但是返回给客户端的时候，数据就即将写入成功了，因为它只剩最后一步了：就是读取 relay log，写入从库。</p></li></ul><p><img src="https://pics5.baidu.com/feed/7c1ed21b0ef41bd54b0be0c8d79badc239db3d78.png?token=9fd4131dc76b0ce4d701189ff5285a85" alt="img"></p><p>半同步复制.png</p><p>如果我们要在数据库里面用半同步复制，必须安装一个插件，这个是谷歌的一位工程师贡献的。这个插件在 mysql 的插件目录下已经有提供：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib64/mysql/plugin/</span><br></pre></td></tr></table></figure><p>主库和从库是不同的插件，安装之后需要启用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 主库执行</span><br><span class="line">INSTALL PLUGIN rpl_semi_sync_master SONAME &#x27;semisync_master.so&#x27;;</span><br><span class="line">set global rpl_semi_sync_master_enabled=1;</span><br><span class="line">show variables like &#x27;%semi_sync%&#x27;;</span><br><span class="line">-- 从库执行</span><br><span class="line">INSTALL PLUGIN rpl_semi_sync_slave SONAME &#x27;semisync_slave.so&#x27;;</span><br><span class="line">set global rpl_semi_sync_slave_enabled=1;</span><br><span class="line">show global variables like &#x27;%semi%&#x27;;</span><br></pre></td></tr></table></figure><p>相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，它需要等待一个 slave 写入中继日志，这里多了一个网络交互的过程，所以，半同步复制最好在低延时的网络中使用。</p><p>这个是从主库和从库连接的角度，来保证 slave 数据的写入。</p><p>另一个思路，如果要减少主从同步的延迟，减少 SQL 执行造成的等待的时间，那有没有办法在从库上，让多个 SQL 语句可以并行执行，而不是排队执行呢？</p><ul><li>多库并行复制</li></ul><p>怎么实现并行复制呢？设想一下，如果 3 条语句是在三个数据库执行，操作各自的数据库，是不是肯定不会产生并发的问题呢？执行的顺序也没有要求。当然是，所以如果是操作三个数据库，这三个数据库的从库的 SQL 线程可以并发执行。这是 MySQL 5.6版本里面支持的多库并行复制。</p><p><img src="https://pics5.baidu.com/feed/c8ea15ce36d3d539c86f11f5bfc6c559352ab004.png?token=7991bd0b5b10bdd6cf3b2d76eb60d9da" alt="img"></p><p>多库并行复制.png</p><p>但是在大部分的情况下，我们都是单库多表的情况，在一个数据库里面怎么实现并行复制呢？或者说，我们知道，数据库本身就是支持多个事务同时操作的；为什么这些事务在主库上面可以并行执行，却不会出现问题呢？</p><p>因为他们本身就是互相不干扰的，比如这些事务是操作不同的表，或者操作不同的行，不存在资源的竞争和数据的干扰。那在主库上并行执行的事务，在从库上肯定也是可以并行执行，是不是？比如在 master 上有三个事务同时分别操作三张表，这三个事务是不是在 slave 上面也可以并行执行呢？</p><ul><li>异步复制之 GTID 复制 dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;replication-gtids.html 所以，我们可以把那些在主库上并行执行的事务，分为一个组，并且给他们编号，这一个组的事务在从库上面也可以并行执行。这个编号，我们把它叫做 GTID（Global Transaction Identifiers），这种主从复制的方式，我们把它叫做基于 GTID 的复制。</li></ul><p><img src="https://pics7.baidu.com/feed/b58f8c5494eef01f89901c2965bfb52cbd317d24.png?token=1017512229c3a0a2bad23d9de4a39152" alt="img"></p><p>GTID复制.png</p><p>如果我们要使用 GTID 复制，我们可以通过修改配置参数打开它，默认是关闭的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#x27;gtid_mode&#x27;;</span><br></pre></td></tr></table></figure><p>无论是优化 master 和 slave 的连接方式，还是让从库可以并行执行 SQL，都是从数据库的层面去解决主从复制延迟的问题。</p><p>除了数据库本身的层面之外，在应用层面，我们也有一些减少主从同步延迟的方法。</p><p>我们在做了主从复制之后，如果单个 master 节点或者单张表存储的数据过大的时候，比如一张表有上亿的数据，单表的查询性能还是会下降，我们要进一步对单台数据库节点的数据分型拆分，这个就是分库分表。</p><ol><li><p>分库分表</p><p>垂直分库，减少并发压力。水平分表，解决存储瓶颈。 垂直分库的做法，把一个数据库按照业务拆分成不同的数据库：</p></li></ol><p><img src="https://pics6.baidu.com/feed/aa64034f78f0f736919c7e368c149f10ebc41374.png?token=a6ca7e08cd7e5ce2301bc0b49987dbfd" alt="img"></p><p>垂直分库.png</p><p>水平分库分表的做法，把单张表的数据按照一定的规则分布到多个数据库。</p><p><img src="https://pics1.baidu.com/feed/aec379310a55b31913cee53dc6e8ae2fcffc1709.png?token=639b011065b3d5f4b345ca28ce5bae53" alt="img"></p><p>水平分库分表.png</p><p>通过主从或者分库分表可以减少单个数据库节点的访问压力和存储压力，达到提升数据库性能的目的，但是如果 master 节点挂了，怎么办？ 所以，高可用（High Available）也是高性能的基础。</p><ol><li>高可用方案 dev.mysql.com&#x2F;doc&#x2F;mysql-ha-scalability&#x2F;en&#x2F;ha-overview.html</li></ol><p><img src="https://pics1.baidu.com/feed/8d5494eef01f3a295066886b1c6490385d607cb7.png?token=2da7e9700c1a354819422304085512bd" alt="img"></p><p>1. </p><p>   cluster-components-1.png</p><ul><li><p>主从复制</p><p>传统的 HAProxy + keepalived 的方案，基于主从复制。</p></li><li><p>NDB Cluster</p><p>dev.mysql.com&#x2F;doc&#x2F;mysql-cluster-excerpt&#x2F;5.7&#x2F;en&#x2F;mysql-cluster-overview.html 基于 NDB 集群存储引擎的 MySQL Cluster。</p></li><li><p>Galera</p><p>galeracluster.com&#x2F;</p><p>一种多主同步复制的集群方案。</p></li></ul><p><img src="https://pics3.baidu.com/feed/79f0f736afc379317c8661ab6e859b4c42a91114.png?token=979f87c303dd0ffcb888a6b25109d958" alt="img"></p><ul><li><p>MHA&#x2F;MMM</p><p>tech.meituan.com&#x2F;2017&#x2F;06&#x2F;29&#x2F;database-availability-architecture.html MMM（Master-Master replication manager for MySQL），一种多主的高可用架构，是一个日本人开发的，像美团这样的公司早期也有大量使用 MMM。 MHA（MySQL Master High Available）。 MMM 和 MHA 都是对外提供一个虚拟 IP，并且监控主节点和从节点，当主节点发生故障的时候，需要把一个从节点提升为主节点，并且把从节点里面比主节点缺少的数据补上，把 VIP 指向新的主节点。</p></li><li><p>MGR</p><p>dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;group-replication.html dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;mysql-cluster.html MySQL 5.7.17 版本推出的 InnoDB Cluster，也叫 MySQL Group Replicatioin（MGR），这个套件里面包括了 mysql shell 和 mysql-route。</p></li></ul><p><img src="https://pics6.baidu.com/feed/58ee3d6d55fbb2fb165a5d26ca0b0cad4623dc5f.png?token=24c95c9683888de76f120a86bde38f6c" alt="img"></p><p>总结一下：</p><p>高可用 HA 方案需要解决的问题都是当一个 master 节点宕机的时候，如何提升一个数据最新的 slave 成为 master。如果同时运行多个 master，又必须要解决 master 之间数据复制，以及对于客户端来说连接路由的问题。 不同的方案，实施难度不一样，运维管理的成本也不一样。 以上是架构层面的优化，可以用缓存，主从，分库分表。</p><p>第三个环节： 解析器，词法和语法分析，主要保证语句的正确性，语句不出错就没问题。由 Sever自己处理，跳过。</p><p>第四步：优化器</p><h3 id="四，优化器——SQL-语句分析与优化"><a href="#四，优化器——SQL-语句分析与优化" class="headerlink" title="四，优化器——SQL 语句分析与优化"></a>四，优化器——SQL 语句分析与优化</h3><p>优化器就是对我们的 SQL 语句进行分析，生成执行计划。 问题：在我们做项目的时候，有时会收到 DBA 的邮件，里面列出了我们项目上几个耗时比较长的查询语句，让我们去优化，这些语句是从哪里来的呢？ 我们的服务层每天执行了这么多 SQL 语句，它怎么知道哪些 SQL 语句比较慢呢？ 第一步，我们要把 SQL 执行情况记录下来。</p><ol><li><p>慢查询日志 slow query log</p><p>dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;slow-query-log.html</p></li></ol><ul><li>打开慢日志开关</li></ul><p>因为开启慢查询日志是有代价的（跟 bin log、optimizer-trace 一样），所以它默认是关闭的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;slow_query%;</span><br></pre></td></tr></table></figure><p><img src="https://pics0.baidu.com/feed/37d3d539b6003af31b0f62a2b16bea551138b601.jpeg?token=17e46ac96c1cd92ed0805f333c05d2f2" alt="img"></p><p>除了这个开关，还有一个参数，控制执行超过多长时间的 SQL 才记录到慢日志，默认是 10 秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%slow_query%&#x27;;</span><br></pre></td></tr></table></figure><p>可以直接动态修改参数（重启后失效）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set @@global.slow_query_log=1; -- 1 开启，0 关闭，重启后失效</span><br><span class="line">set @@global.long_query_time=3; -- mysql 默认的慢查询时间是 10 秒，另开一个窗口后才会查到最新值</span><br><span class="line">show variables like &#x27;%long_query%&#x27;;</span><br><span class="line">show variables like &#x27;%slow_query%;</span><br></pre></td></tr></table></figure><p>或者修改配置文件 my.cnf。 以下配置定义了慢查询日志的开关、慢查询的时间、日志文件的存放路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log = ON</span><br><span class="line">long_query_time=2</span><br><span class="line">slow_query_log_file =/var/lib/mysql/localhost-slow.log</span><br></pre></td></tr></table></figure><p>模拟慢查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sleep(10);</span><br></pre></td></tr></table></figure><p>查询 user_innodb 表的 500 万数据（检查是不是没有索引）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user_innodb` where phone = &#x27;136&#x27;;</span><br></pre></td></tr></table></figure><ul><li>慢日志分析</li></ul><ol><li>日志内容</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show global status like &#x27;slow_queries&#x27;; -- 查看有多少慢查询</span><br><span class="line">show variables like &#x27;%slow_query%&#x27;; -- 获取慢日志目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/mysql/ localhost-slow.log</span><br></pre></td></tr></table></figure><p><img src="https://pics5.baidu.com/feed/9213b07eca806538c78b7aaa119c8d4dac3482f5.png?token=bddc3c02fadf778949eebd94d989eec2" alt="img"></p><p>有了慢查询日志，怎么去分析统计呢？比如 SQL 语句的出现的慢查询次数最多，平均每次执行了多久？</p><ol><li>mysqldumpslow dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;mysqldumpslow.html MySQL 提供了 mysqldumpslow 的工具，在 MySQL 的 bin 目录下。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure><p>例如：查询用时最多的 20 条慢 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t 20 -g &#x27;select&#x27; /var/lib/mysql/localhost-</span><br></pre></td></tr></table></figure><p><img src="https://pics7.baidu.com/feed/cf1b9d16fdfaaf51c29718de0b15b8e7f01f7a21.png?token=e63ea3a1ab7ffcc82787cb837452922c" alt="img"></p><p>Count 代表这个 SQL 执行了多少次； Time 代表执行的时间，括号里面是累计时间； Lock 表示锁定的时间，括号是累计； Rows 表示返回的记录数，括号是累计。</p><p>除了慢查询日志之外，还有一个 SHOW PROFILE 工具可以使用.</p><ol><li>SHOW PROFILE</li></ol><p>dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;show-profile.html SHOW PROFILE 是谷歌高级架构师 Jeremy Cole 贡献给 MySQL 社区的，可以查看SQL 语句执行的时候使用的资源，比如 CPU、IO 的消耗情况。 在 SQL 中输入 help profile 可以得到详细的帮助信息.</p><ul><li>查看是否开启</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@profiling;</span><br><span class="line">set @@profiling=1;</span><br></pre></td></tr></table></figure><ul><li><p>查看 profile 统计</p><p>（命令最后带一个 s）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure><p><img src="https://pics1.baidu.com/feed/4e4a20a4462309f74bd13479fb4f20fad6cad6ee.jpeg?token=8361249896e019aef9534b0d01b5320b" alt="img"></p><p>查看最后一个 SQL 的执行详细信息，从中找出耗时较多的环节（没有 s）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile;</span><br></pre></td></tr></table></figure><p><img src="https://pics4.baidu.com/feed/242dd42a2834349b90bb4b324cab39c737d3be96.jpeg?token=b3f337a5eedddae8bbc53ca92efde742" alt="img"></p><p>6.2E-5，小数点左移 5 位，代表 0.000062 秒。</p><p>也可以根据 ID 查看执行详细信息，在后面带上 for query + ID.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile for query 1;</span><br></pre></td></tr></table></figure><p>除了慢日志和 show profile，如果要分析出当前数据库中执行的慢的 SQL，还可以通过查看运行线程状态和服务器运行信息、存储引擎信息来分析。</p><ul><li>其他系统命令</li></ul><p>show processlist 运行线程</p><p>dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;show-processlist.html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure><p>这是很重要的一个命令，用于显示用户运行线程。可以根据 id 号 kill 线程。 也可以查表，效果一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.processlist;</span><br></pre></td></tr></table></figure><p><img src="https://pics1.baidu.com/feed/1e30e924b899a901759b5df798d426720308f50b.png?token=88a96dc9792c065832495ab3e9cafe73" alt="img"></p><p>show status 服务器运行状态</p><p>dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;show-status.html SHOW STATUS 用于查看 MySQL 服务器运行状态（重启后会清空），有 session和 global 两种作用域，格式：参数-值。 可以用 like 带通配符过滤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;com_select&#x27;; -- 查看 select 次数</span><br></pre></td></tr></table></figure><p>show engine 存储引擎运行信息</p><p>dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;show-engine.html show engine 用来显示存储引擎的当前运行信息，包括事务持有的表锁、行锁信息；事务的锁等待情况；线程信号量等待；文件 IO 请求；buffer pool 统计信息。 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure><p>如果需要将监控信息输出到错误信息 error log 中（15 秒钟一次），可以开启输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_status_output%&#x27;; -- 开启输出：</span><br><span class="line">SET GLOBAL innodb_status_output=ON;</span><br><span class="line">SET GLOBAL innodb_status_output_locks=ON;</span><br></pre></td></tr></table></figure><p>我们现在已经知道了这么多分析服务器状态、存储引擎状态、线程运行信息的命令，如果让你去写一个数据库监控系统，你会怎么做？ 其实很多开源的慢查询日志监控工具，他们的原理其实也都是读取的系统的变量和状态。</p><p>现在我们已经知道哪些 SQL 慢了，为什么慢呢？慢在哪里?</p><p>MySQL 提供了一个执行计划的工具（在架构中我们有讲到，优化器最终生成的就是一个执行计划），其他数据库，例如 Oracle 也有类似的功能。 通过 EXPLAIN 我们可以模拟优化器执行 SQL 查询语句的过程，来知道 MySQL 是怎么处理一条 SQL 语句的。通过这种方式我们可以分析语句或者表的性能瓶颈。 explain 可以分析 update、delete、insert 么？ MySQL 5.6.3以前只能分析 SELECT; MySQL5.6.3以后就可以分析update、delete、insert 了.</p><ol><li>EXPLAIN 执行计划</li></ol><p>官方链接：dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;explain-output.html 我们先创建三张表。一张课程表，一张老师表，一张老师联系方式表（没有任何索引）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS course;</span><br><span class="line">CREATE TABLE `course` (</span><br><span class="line">`cid` int(3) DEFAULT NULL, `cname` varchar(20) DEFAULT NULL, `tid` int(3) DEFAULT NUL) ENGINE=InnoDB DEFAULTCHARSET=utf8mb4;</span><br><span class="line">DROP TABLE IF EXISTS teacher;</span><br><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">`tid` int(3) DEFAULT NULL, `tname` varchar(20) DEFAULT NULL, `tcid` int(3) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">DROP TABLE IF EXISTS teacher_contact;</span><br><span class="line">CREATE TABLE `teacher_contact` (</span><br><span class="line">`tcid` int(3) DEFAULT NULL, `phone` varchar(200) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">INSERT INTO `course` VALUES (&#x27;1&#x27;, &#x27;mysql&#x27;, );</span><br><span class="line">INSERT INTO `course` VALUES (&#x27;2&#x27;, &#x27;jvm&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `course` VALUES (&#x27;3&#x27;, &#x27;juc&#x27;, &#x27;2&#x27;);</span><br><span class="line">INSERT INTO `course` VALUES (&#x27;4&#x27;, &#x27;spring&#x27;, &#x27;3&#x27;);</span><br><span class="line">INSERT INTO `teacher` VALUES (&#x27;1&#x27;, &#x27;qingshan&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `teacher` VALUES (&#x27;2&#x27;, &#x27;jack&#x27;, &#x27;2&#x27;);</span><br><span class="line">INSERT INTO `teacher` VALUES (&#x27;3&#x27;, &#x27;mic&#x27;, &#x27;3&#x27;);</span><br><span class="line">INSERT INTO `teacher_contact` VALUES (&#x27;1&#x27;, &#x27;13688888888&#x27;);</span><br><span class="line">INSERT INTO `teacher_contact` VALUES (&#x27;2&#x27;, &#x27;18166669999&#x27;);</span><br><span class="line">INSERT INTO `teacher_contact` VALUES (&#x27;3&#x27;, &#x27;17722225555&#x27;)</span><br></pre></td></tr></table></figure><p>explain 的结果有很多的字段，我们详细地分析一下。 先确认一下环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select version();</span><br><span class="line">show variables like &#x27;%engine%&#x27;;</span><br></pre></td></tr></table></figure><ul><li>id</li></ul><p>id 是查询序列编号</p><p><strong>id 值不同</strong></p><p>id 值不同的时候，先查询 id 值大的（先大后小）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 mysql 课程的老师手机号</span><br><span class="line">EXPLAIN SELECT tc.phone</span><br><span class="line">FROM teacher_contact tc</span><br><span class="line">WHERE tcid = (</span><br><span class="line">SELECT tcid</span><br><span class="line">FROM teacher t</span><br><span class="line">WHERE t.tid = (</span><br><span class="line">SELECT c.tid</span><br><span class="line">FROM course c</span><br><span class="line">WHERE c.cname = &#x27;mysql&#x27; )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>查询顺序：course c——teacher t——teacher_contact t.</p><p><img src="https://pics4.baidu.com/feed/241f95cad1c8a78615a059c6eb48e53471cf503e.png?token=a1a7bf80ed7735aa843613a3ce418552" alt="img"></p><p>先查课程表，再查老师表，最后查老师联系方式表。子查询只能以这种方式进行，只有拿到内层的结果之后才能进行外层的查询。</p><p><strong>id 值相同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询课程 ID 为 2，或者联系表 ID 为 3 的老师</span><br><span class="line">EXPLAIN</span><br><span class="line">SELECT t.tname,c.cname,tc.phone</span><br><span class="line">FROM teacher t, course c, teacher_contact tc</span><br><span class="line">WHERE t.tid = c.tid</span><br><span class="line">AND t.tcid = tc.tcid</span><br><span class="line">AND (c.cid = 2</span><br><span class="line">OR tc.tcid = 3);</span><br></pre></td></tr></table></figure><p><img src="https://pics7.baidu.com/feed/622762d0f703918fd0850e6ddd7c0a9e58eec48f.png?token=76194120b3b35ce20d25d116eaa32e28" alt="img"></p><p>id 值相同时，表的查询顺序是从上往下顺序执行。例如这次查询的 id 都是 1，查询的顺序是 teacher t（3 条）——course c（4 条）——teacher_contact tc（3 条）。 teacher 表插入 3 条数据后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `teacher` VALUES (4, &#x27;james&#x27;, 4);</span><br><span class="line">INSERT INTO `teacher` VALUES (5, &#x27;tom&#x27;, 5);</span><br><span class="line">INSERT INTO `teacher` VALUES (6, &#x27;seven&#x27;, 6);</span><br><span class="line">COMMIT; -- （备份）恢复语句</span><br><span class="line">DELETE FROM teacher where tid in (4,5,6);</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>id 也都是 1，但是从上往下查询顺序变成了：teacher_contact tc（3 条）——teacher t（6 条）——course c（4 条）。</p><p><img src="https://pics2.baidu.com/feed/b999a9014c086e061a17550f8f4957fd0bd1cb85.png?token=ede060ef2b775d907b2a853137ef6a20" alt="img"></p><p>为什么数据量不同的时候顺序会发生变化呢？这个是由笛卡尔积决定的。</p><p>举例：假如有 a、b、c 三张表，分别有 2、3、4 条数据，如果做三张表的联合查询，当查询顺序是 a→b→c 的时候，它的笛卡尔积是：2<em>3</em>4&#x3D;6<em>4&#x3D;24。如果查询顺序是 c→b→a，它的笛卡尔积是 4</em>3<em>2&#x3D;12</em>2&#x3D;24。</p><p>因为 MySQL 要把查询的结果，包括中间结果和最终结果都保存到内存，所以 MySQL会优先选择中间结果数据量比较小的顺序进行查询。所以最终联表查询的顺序是 a→b→c。这个就是为什么 teacher 表插入数据以后查询顺序会发生变化。 （小标驱动大表的思想）</p><p><strong>既有相同也有不同</strong></p><p>如果 ID 有相同也有不同，就是 ID 不同的先大后小，ID 相同的从上往下。</p><ul><li><p>select type 查询类型</p><p>这里并没有列举全部（其它：DEPENDENT UNION、DEPENDENT SUBQUERY、MATERIALIZED、UNCACHEABLE SUBQUERY、UNCACHEABLE UNION）。 下面列举了一些常见的查询类型：</p><p><strong>SIMPLE</strong></p></li></ul><p>简单查询，不包含子查询，不包含关联查询 union。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM teacher;</span><br></pre></td></tr></table></figure><p><img src="https://pics0.baidu.com/feed/faf2b2119313b07e94ef32cf8996bd2a96dd8c75.png?token=9c87760303930ba5413ec549ba343836" alt="img"></p><p>再看一个包含子查询的案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 mysql 课程的老师手机号</span><br><span class="line">EXPLAIN SELECT tc.phone</span><br><span class="line">FROM teacher_contact tc</span><br><span class="line">WHERE tcid = (</span><br><span class="line">SELECT tcid</span><br><span class="line">FROM teacher t</span><br><span class="line">WHERE t.tid = (</span><br><span class="line">SELECT c.tid</span><br><span class="line">FROM course c</span><br><span class="line">WHERE c.cname = &#x27;mysql&#x27; )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://pics7.baidu.com/feed/f703738da9773912f465a0c37d58aa11377ae29f.png?token=1428b8bcbcda71db887a4542258202df" alt="img"></p><p><strong>PRIMARY</strong></p><p>子查询 SQL 语句中的主查询，也就是最外面的那层查询。</p><p><strong>SUBQUERY</strong></p><p>子查询中所有的内层查询都是 SUBQUERY 类型的。</p><p><strong>DERIVED</strong></p><p>衍生查询，表示在得到最终查询结果之前会用到临时表。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 ID 为 1 或 2 的老师教授的课程</span><br><span class="line">EXPLAIN SELECT cr.cname</span><br><span class="line">FROM (</span><br><span class="line">SELECT * FROM course WHERE tid = 1</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM course WHERE tid = 2</span><br><span class="line">) cr;</span><br></pre></td></tr></table></figure><p><img src="https://pics4.baidu.com/feed/3b292df5e0fe99259f369f34b3e972d68db17162.png?token=7c40411fa3546cbee204b6cfd59d7684" alt="img"></p><p>对于关联查询，先执行右边的 table（UNION），再执行左边的 table，类型是DERIVED。</p><p><strong>UNION</strong></p><p>用到了 UNION 查询。同上例。</p><p><strong>UNION RESULT</strong></p><p>主要是显示哪些表之间存在 UNION 查询。代表 id&#x3D;2 和 id&#x3D;3 的查询存在 UNION。同上例。</p><ul><li><p>type 连接类型</p><p>dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;explain-output.html#explain-join-types 所有的连接类型中，上面的最好，越往下越差。 在常用的链接类型中：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all 这 里 并 没 有 列 举 全 部 （ 其 他 ： fulltext 、 ref_or_null 、 index_merger 、unique_subquery、index_subquery）。 以上访问类型除了 all，都能用到索引。 <strong>const</strong></p><p>主键索引或者唯一索引，只能查到一条数据的 SQL。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS single_data;</span><br><span class="line">CREATE TABLE single_data(</span><br><span class="line">id int(3) PRIMARY KEY, content varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into single_data values(1,&#x27;a&#x27;);</span><br><span class="line">EXPLAIN SELECT * FROM single_data a where id = 1;</span><br></pre></td></tr></table></figure><p><img src="https://pics7.baidu.com/feed/279759ee3d6d55fbda645823eb63634321a4dddb.png?token=866fb5f934cbf97869b0947b29473087" alt="img"></p><p><strong>system</strong> system 是 const 的一种特例，只有一行满足条件。例如：只有一条数据的系统表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM mysql.proxies_priv;</span><br></pre></td></tr></table></figure><p><img src="https://pics7.baidu.com/feed/21a4462309f79052139a8b0b81b2fbc37acbd5cd.png?token=123274bc294e49de896b13437a6ab84a" alt="img"></p><p><strong>eq_ref</strong></p><p>通常出现在多表的 join 查询，表示对于前表的每一个结果,都只能匹配到后表的一行结果。一般是唯一性索引的查询（UNIQUE 或 PRIMARY KEY）。 eq_ref 是除 const 之外最好的访问类型。 先删除 teacher 表中多余的数据，teacher_contact 有 3 条数据，teacher 表有 3条数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM teacher where tid in (4,5,6);</span><br><span class="line">commit; -- 备份</span><br><span class="line">INSERT INTO `teacher` VALUES (4, &#x27;james&#x27;, 4);</span><br><span class="line">INSERT INTO `teacher` VALUES (5, &#x27;tom&#x27;, 5);</span><br><span class="line">INSERT INTO `teacher` VALUES (6, &#x27;seven&#x27;, 6);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>为 teacher_contact 表的 tcid（第一个字段）创建主键索.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- ALTER TABLE teacher_contact DROP PRIMARY KEY;</span><br><span class="line">ALTER TABLE teacher_contact ADD PRIMARY KEY(tcid);</span><br></pre></td></tr></table></figure><p>为 teacher 表的 tcid（第三个字段）创建普通索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- ALTER TABLE teacher DROP INDEX idx_tcid;</span><br><span class="line">ALTER TABLE teacher ADD INDEX idx_tcid (tcid</span><br></pre></td></tr></table></figure><p>执行以下 SQL 语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t.tcid from teacher t,teacher_contact tc where t.tcid = tc.tcid;</span><br></pre></td></tr></table></figure><p><img src="https://pics7.baidu.com/feed/908fa0ec08fa513d467d7839b92c79f2b0fbd9c8.jpeg?token=b2cb9a16ffa1870f4d09db2644ae51ae" alt="img"></p><p>此时的执行计划（teacher_contact 表是 eq_ref:</p><p><img src="https://pics1.baidu.com/feed/d0c8a786c9177f3ee0454af7f68e17ce9e3d56a5.png?token=08ae084628cdcac3055a87a39c8b1dff" alt="img"></p><p><strong>小结：</strong></p><p>以上三种 system，const，eq_ref，都是可遇而不可求的，基本上很难优化到这个状态。</p><p><strong>ref</strong></p><p>查询用到了非唯一性索引，或者关联操作只使用了索引的最左前缀。 例如：使用 tcid 上的普通索引查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM teacher where tcid = 3;</span><br></pre></td></tr></table></figure><p><img src="https://pics6.baidu.com/feed/8c1001e93901213f9cd4d343d1a61ad82e2e9510.png?token=2cc87b8b04dbb0bda450518350c995dc" alt="img"></p><p><strong>range</strong></p><p>索引范围扫描。 如果 where 后面是 between and 或 &lt;或 &gt; 或 &gt;&#x3D; 或 &lt;&#x3D;或 in 这些，type 类型就为 range。 不走索引一定是全表扫描（ALL），所以先加上普通索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- ALTER TABLE teacher DROP INDEX idx_tid;</span><br><span class="line">ALTER TABLE teacher ADD INDEX idx_tid (tid);</span><br></pre></td></tr></table></figure><p>执行范围查询（字段上有普通索引）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM teacher t WHERE t.tid &lt;3; -- 或</span><br><span class="line">EXPLAIN SELECT * FROM teacher t WHERE tid BETWEEN 1 AND 2;</span><br></pre></td></tr></table></figure><p><img src="https://pics3.baidu.com/feed/6159252dd42a2834ccf1a924def4e5e315cebf11.png?token=b020ae37f4218e1a3462fc7dcd3059b1" alt="img"></p><p>IN 查询也是 range（字段有主键索引)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM teacher_contact t WHERE tcid in (1,2,3);</span><br></pre></td></tr></table></figure><p><img src="https://pics7.baidu.com/feed/9345d688d43f8794baaa87825e5a22fd1ad53a8b.png?token=e9fe1609ba29f90d273b3b23bf999668" alt="img"></p><p><strong>index</strong></p><p>Full Index Scan，查询全部索引中的数据（比不走索引要快）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT tid FROM teacher;</span><br></pre></td></tr></table></figure><p><img src="https://pics6.baidu.com/feed/c75c10385343fbf2d1d6dd09363fe68964388fe8.png?token=5778864b4eb4ce6b9d74a71d05e11035" alt="img"></p><p>v18.png</p><p><strong>all</strong></p><p>Full Table Scan，如果没有索引或者没有用到索引，type 就是 ALL。代表全表扫描。</p><p><strong>NULL</strong></p><p>不用访问表或者索引就能得到结果，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select 1 from dual where 1=1;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong> 一般来说，需要保证查询至少达到 range 级别，最好能达到 ref。 ALL（全表扫描）和 index（查询全部索引）都是需要优化的。</p><ul><li>possible_key、key</li></ul><p>可能用到的索引和实际用到的索引。如果是 NULL 就代表没有用到索引。 possible_key 可以有一个或者多个，可能用到索引不代表一定用到索引。 反过来，possible_key 为空，key 可能有值吗？ 表上创建联合索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user_innodb DROP INDEX comidx_name_phone;</span><br><span class="line">ALTER TABLE user_innodb add INDEX comidx_name_phone (name,phone);</span><br></pre></td></tr></table></figure><p>执行计划（改成 select name 也能用到索引）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select phone from user_innodb where phone=&#x27;126&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://pics0.baidu.com/feed/77c6a7efce1b9d168d89c9987f9f98868d546443.png?token=acf68f9ad120749d403a231c2b230dd9" alt="img"></p><p>结论：是有可能的（这里是覆盖索引的情况）。 如果通过分析发现没有用到索引，就要检查 SQL 或者创建索引.</p><ul><li><p>key_len</p><p>索引的长度（使用的字节数）。跟索引字段的类型、长度有关。</p></li><li><p>rows</p><p>MySQL 认为扫描多少行才能返回请求的数据，是一个预估值。一般来说行数越少越好。</p></li><li><p>filtered</p><p>这个字段表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例，它是一个百分比。</p></li><li><p>ref</p><p>使用哪个列或者常数和索引一起从表中筛选数据。</p></li><li><p>Extra</p><p>执行计划给出的额外的信息说明。</p></li></ul><p><strong>using index</strong></p><p>用到了覆盖索引，不需要回表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT tid FROM teacher ;</span><br></pre></td></tr></table></figure><p><strong>using where</strong></p><p>使用了 where 过滤，表示存储引擎返回的记录并不是所有的都满足查询条件，需要在 server 层进行过滤（跟是否使用索引没有关系）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select * from user_innodb where phone =&#x27;13866667777&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://pics1.baidu.com/feed/c9fcc3cec3fdfc0313b543ec5e7eab9da5c2265b.png?token=84524652dacfb9b16b74be8bf1ac6d88" alt="img"></p><p>v20.png</p><p><strong>Using index condition（索引条件下推）</strong></p><p>索引下推，在第二章中已经讲解过了。 dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;index-condition-pushdown-optimization.htm</p><p><strong>using filesort</strong></p><p>不能使用索引来排序，用到了额外的排序（跟磁盘或文件没有关系）。需要优化。 （复合索引的前提）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user_innodb DROP INDEX comidx_name_phone;</span><br><span class="line">ALTER TABLE user_innodb add INDEX comidx_name_phone (name,phone);</span><br><span class="line">EXPLAIN select * from user_innodb where name=&#x27;青山&#x27; order by id;</span><br></pre></td></tr></table></figure><p>（order by id 引起）</p><p><img src="https://pics3.baidu.com/feed/f603918fa0ec08fa3aa4350ddfaf116454fbdaba.png?token=cbed051d4ae8259967d5f1b946736c24" alt="img"></p><p><strong>using temporary</strong></p><p>用到了临时表。例如（以下不是全部的情况）： </p><p>1、distinct 非索引列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select DISTINCT(tid) from teacher t;</span><br></pre></td></tr></table></figure><p>2、group by 非索引列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select tname from teacher group by tname;</span><br></pre></td></tr></table></figure><p>3、用 join 的时候，group 任意列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select t.tid from teacher t join course c on t.tid = c.tid group by t.tid;</span><br></pre></td></tr></table></figure><p>需要优化，例如创建复合索引。</p><p>总结一下： 模拟优化器执行 SQL 查询语句的过程，来知道 MySQL 是怎么处理一条 SQL 语句的。 通过这种方式我们可以分析语句或者表的性能瓶颈。 分析出问题之后，就是对 SQL 语句的具体优化。 比如怎么用到索引，怎么减少锁的阻塞等待，在前面已经讲过。</p><ol><li><p>SQL 与索引优</p><p>当我们的 SQL 语句比较复杂，有多个关联和子查询的时候，就要分析 SQL 语句有没有改写的方法。 举个简单的例子，一模一样的数据：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 大偏移量的 limit</span><br><span class="line">select * from user_innodb limit 900000,10; -- 改成先过滤 ID，再 limit</span><br><span class="line">SELECT * FROM user_innodb WHERE id &gt;= 900000 LIMIT 10;</span><br></pre></td></tr></table></figure><p>于具体的 SQL 语句的优化，MySQL 官网也提供了很多建议，这个是我们在分析具体的 SQL 语句的时候需要注意的，也是大家在以后的工作里面要去慢慢地积累的（这里我们就不一一地分析了）。</p><p>dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;optimization.html</p><h3 id="五，存储引擎"><a href="#五，存储引擎" class="headerlink" title="五，存储引擎"></a>五，存储引擎</h3><ol><li><p>存储引擎的选择</p><p>为不同的业务表选择不同的存储引擎，例如：查询插入操作多的业务表，用 MyISAM。 临时数据用 Memeroy。常规的并发大更新多的表用 InnoDB。</p></li><li><p>分区或者分表</p><p>分区不推荐。 交易历史表：在年底为下一年度建立 12 个分区，每个月一个分区。 渠道交易表：分成当日表；当月表；历史表，历史表再做分区。</p></li><li><p>字段定义</p><p>原则：使用可以正确存储数据的最小数据类型。 为每一列选择合适的字段类型：</p></li></ol><p><img src="https://pics3.baidu.com/feed/3ac79f3df8dcd1001e01a352f7ca6b19b8122fea.jpeg?token=cb55f1b71aa4529b9c5a24112dfb240d" alt="img"></p><ul><li>整数类型</li></ul><p>INT 有 8 种类型，不同的类型的最大存储范围是不一样的。 性别？用 TINYINT，因为 ENUM 也是整型存储。</p><ul><li><p>字符类型</p><p>变长情况下，varchar 更节省空间，但是对于 varchar 字段，需要一个字节来记录长度。</p><p>固定长度的用 char，不要用 varchar。</p></li><li><p>非空</p><p>非空字段尽量定义成 NOT NULL，提供默认值，或者使用特殊值、空串代替 null。 NULL 类型的存储、优化、使用都会存在问题。</p></li><li><p>不要用外键、触发器、视图</p><p>降低了可读性； 影响数据库性能，应该把把计算的事情交给程序，数据库专心做存储； 数据的完整性应该在程序中检查。</p></li><li><p>大文件存储</p><p>不要用数据库存储图片（比如 base64 编码）或者大文件； 把文件放在 NAS 上，数据库只需要存储 URI（相对路径），在应用中配置 NAS 服务器地址。</p></li><li><p>表拆分</p><p>将不常用的字段拆分出去，避免列数过多和数据量过大。 比如在业务系统中，要记录所有接收和发送的消息，这个消息是 XML 格式的，用blob 或者 text 存储，用来追踪和判断重复，可以建立一张表专门用来存储报文。</p></li></ul><h3 id="六，总结：优化体系"><a href="#六，总结：优化体系" class="headerlink" title="六，总结：优化体系"></a>六，总结：优化体系</h3><p><img src="https://pics3.baidu.com/feed/0eb30f2442a7d9331a838ec3210afd1a73f00125.jpeg?token=87bedbd9f9bca17ec94ec8f21f5560bf" alt="img"></p><p>除了对于代码、SQL 语句、表定义、架构、配置优化之外，业务层面的优化也不能忽视。举几个例子： 1）在某一年的双十一，为什么会做一个充值到余额宝和余额有奖金的活动（充 300送 50）？ 因为使用余额或者余额宝付款是记录本地或者内部数据库，而使用银行卡付款，需要调用接口，操作内部数据库肯定更快。 2）在去年的双十一，为什么在凌晨禁止查询今天之外的账单？这是一种降级措施，用来保证当前最核心的业务。 3）最近几年的双十一，为什么提前一个多星期就已经有双十一当天的价格了？ 预售分流。 在应用层面同样有很多其他的方案来优化，达到尽量减轻数据库的压力的目的，比如限流，或者引入 MQ 削峰，等等等等。 为什么同样用 MySQL，有的公司可以扛住百万千万级别的并发，而有的公司几百个并发都扛不住，关键在于怎么用。所以，用数据库慢，不代表数据库本身慢，有的时候还要往上层去优化。</p><p>当然，如果关系型数据库解决不了的问题，我们可能需要用到搜索引擎或者大数据的方案了，并不是所有的数据都要放到关系型数据库存储。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jiale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2022/07/11/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2022/07/11/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
